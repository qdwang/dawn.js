// Generated by CoffeeScript 1.8.0
(function() {
  var BNFGrammar, log, ulti;

  if (typeof self === 'undefined') {
    ulti = require('./ulti.js');
  } else {
    ulti = self.ulti;
  }

  BNFGrammar = function(bnf_raw_content) {
    var grammar_lines, grammar_lines_arr;
    this.raw_bnf_grammar = bnf_raw_content;
    grammar_lines = bnf_raw_content.split('\n');
    grammar_lines_arr = this.grammarPrepare(grammar_lines);
    this.bnf_grammar_pairs = grammar_lines_arr;
    return this;
  };

  BNFGrammar.prototype.grammarPrepare = function(grammar_lines) {
    var line, line_arr, production, repr_walker, ret, _i, _len;
    ret = [];
    repr_walker = function(repr) {
      var can_split, char, repr_arr, _i, _j, _len, _len1, _results;
      repr_arr = [''];
      can_split = true;
      for (_i = 0, _len = repr.length; _i < _len; _i++) {
        char = repr[_i];
        if (char === '(' || char === '[') {
          can_split = false;
        } else if (char === ')' || char === ']') {
          can_split = true;
        }
        if (char === '|' && can_split) {
          repr_arr.push('');
        } else {
          repr_arr[repr_arr.length - 1] += char;
        }
      }
      _results = [];
      for (_j = 0, _len1 = repr_arr.length; _j < _len1; _j++) {
        repr = repr_arr[_j];
        _results.push(repr.trim());
      }
      return _results;
    };
    for (_i = 0, _len = grammar_lines.length; _i < _len; _i++) {
      line = grammar_lines[_i];
      production = [];
      line_arr = line.split('->');
      production.push(line_arr[0].trim());
      production.push(repr_walker(line_arr[1]));
      ret.push(production);
    }
    return ret;
  };

  BNFGrammar.isOneOrMore = function(closure) {
    return closure.length > 1 && '+' === closure.slice(-1);
  };

  BNFGrammar.removeSpecialMark = function(closure) {
    return closure.replace(/[\[\]\(\)\*\+]+/g, '');
  };

  BNFGrammar.hasSpecialMark = function(closure) {
    return closure.match(/[\[\]\(\)\*\+]+/);
  };

  BNFGrammar.prototype.makePlainBNF = function(stop) {
    var additional_reprs, expandBNF, expanded_reprs, new_bnf, pairs, repr, rules, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    rules = {
      group: /[\(\[][^\s].+?[^\s][\)\]]/g
    };
    expandBNF = function(repr) {
      var E, e_suffix, each_lex, each_lex_arr, i, lex, lexes, matched_lex, ret, x, _i, _j, _len, _len1;
      ret = {
        e: [],
        reprs: []
      };
      if (matched_lex = repr.match(rules.group)) {
        for (_i = 0, _len = matched_lex.length; _i < _len; _i++) {
          each_lex = matched_lex[_i];
          e_suffix = (new Date).getTime() + Math.random();
          E = 'E!' + e_suffix.toString(36);
          E = E.replace('.', '');
          repr = repr.replace(each_lex, each_lex[0] === '[' ? '[' + E + ']' : E);
          each_lex = each_lex.replace(/\(|\)|\[|\]/g, '');
          each_lex_arr = (function() {
            var _j, _len1, _ref, _results;
            _ref = each_lex.split('|');
            _results = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              x = _ref[_j];
              _results.push(x.trim());
            }
            return _results;
          })();
          ret.e.push([E, each_lex_arr]);
        }
      }
      lexes = repr.split(/\s+/);
      for (i = _j = 0, _len1 = lexes.length; _j < _len1; i = ++_j) {
        lex = lexes[i];
        if (lex.length > 1 && '*' === lex.slice(-1)) {
          lexes[i] = ['', (lex.slice(0, -1)) + '+'];
        } else if (lex[0] === '[') {
          lexes[i] = ['', lex.slice(1, -1)];
        } else {
          lexes[i] = [lex];
        }
      }
      ret.reprs = ulti.stripEmptyOfList(ulti.makeCombination(lexes));
      ret.reprs = ret.reprs.map(function(x) {
        return x.join(' ');
      });
      return ret;
    };
    additional_reprs = [];
    _ref = this.bnf_grammar_pairs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pairs = _ref[_i];
      if (!(pairs[1] instanceof Array)) {
        pairs[1] = [pairs[1]];
      }
      expanded_reprs = [];
      _ref1 = pairs[1];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        repr = _ref1[_j];
        new_bnf = expandBNF(repr);
        if (new_bnf.e.length) {
          additional_reprs = additional_reprs.concat(new_bnf.e);
        }
        expanded_reprs = expanded_reprs.concat(new_bnf.reprs);
      }
      pairs[1] = expanded_reprs;
    }
    for (_k = 0, _len2 = additional_reprs.length; _k < _len2; _k++) {
      repr = additional_reprs[_k];
      this.bnf_grammar_pairs.push(repr);
    }
    if (!stop) {
      return this.makePlainBNF(1);
    }
  };

  if (typeof self === 'undefined') {
    module.exports.BNFGrammar = BNFGrammar;
  } else {
    self.BNFGrammar = BNFGrammar;
  }

  log = function() {};

  log = ulti.log;

}).call(this);

//# sourceMappingURL=BNF-parser.js.map
