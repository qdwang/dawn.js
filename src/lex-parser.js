// Generated by CoffeeScript 1.7.1
(function() {
  var LexParser, log, ulti;

  if (typeof self === 'undefined') {
    ulti = require('./ulti.js');
  } else {
    ulti = self.ulti;
  }

  LexParser = function(script, syntax) {
    this.script = script;
    this.lex_syntax = syntax;
    this.lex_list = [];
    this.cursor_lex = null;
    return this;
  };

  LexParser.flow = function(args) {
    var cursor_pos, lex_syntax, lp, script;
    console.log('LexParser');
    script = args.script;
    lex_syntax = args.lex_syntax;
    cursor_pos = args.cursor_pos;
    lp = new LexParser(script, lex_syntax);
    lp.tokenize(cursor_pos);
    lp.lex_list.push('ProgramEnd');
    args.lex_list = lp.lex_list;
    args.cursor_lex = lp.cursor_lex;
    return args.end_lex = ['ProgramEnd'];
  };

  LexParser.prototype.tokenize = function(cursor_pos) {
    var lex, lex_obj, match, match_lex_len, new_script_arr, offset, prefix, script_arr, str, syntax_name, unit, unit_arr, _i, _len;
    lex_obj = {};
    script_arr = [this.script];
    for (syntax_name in this.lex_syntax) {
      offset = 0;
      new_script_arr = [];
      for (_i = 0, _len = script_arr.length; _i < _len; _i++) {
        unit = script_arr[_i];
        if (typeof unit === 'number') {
          offset += unit;
          new_script_arr.push(unit);
        } else {
          str = unit;
          unit_arr = [];
          while (match = this.lex_syntax[syntax_name].exec(str)) {
            offset += match.index;
            match_lex_len = match[0].length;
            lex = [syntax_name, match[0]];
            lex_obj[offset] = lex;
            if (!this.cursor_lex && cursor_pos && cursor_pos > offset && cursor_pos <= offset + match_lex_len) {
              this.cursor_lex = lex;
            }
            prefix = str.slice(0, match.index);
            if (!prefix.trim()) {
              unit_arr.push(prefix.length);
            } else {
              unit_arr.push(prefix);
            }
            unit_arr.push(match_lex_len);
            str = str.slice(match.index + match_lex_len);
            offset += match_lex_len;
          }
          if (!str.trim()) {
            unit_arr.push(str.length);
          } else {
            unit_arr.push(str);
          }
          offset += str.length;
          new_script_arr = new_script_arr.concat(unit_arr);
        }
      }
      script_arr = new_script_arr;
    }
    for (lex in lex_obj) {
      this.lex_list.push(lex_obj[lex]);
    }
    return this;
  };

  if (typeof self === 'undefined') {
    module.exports.LexParser = LexParser;
  } else {
    self.LexParser = LexParser;
  }

  log = function() {};

  log = ulti.log;

}).call(this);

//# sourceMappingURL=lex-parser.map
