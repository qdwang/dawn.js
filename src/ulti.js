// Generated by CoffeeScript 1.7.1
(function() {
  var i, ulti,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  ulti = {
    uniquePush: function(arr, elem) {
      if (__indexOf.call(arr, elem) < 0) {
        return arr.push(elem);
      }
    },
    uniqueConcat: function(arr, elem_arr) {
      var i, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = elem_arr.length; _i < _len; _i++) {
        i = elem_arr[_i];
        _results.push(ulti.uniquePush(arr, i));
      }
      return _results;
    },
    makeCombination: function(lists) {
      var copy_lists, makeCombinationOfTwo, result;
      makeCombinationOfTwo = function(last_list, remain_lists) {
        var last_item, next_item, next_list, ret, _i, _j, _len, _len1;
        next_list = remain_lists.shift();
        if (next_list === void 0) {
          return last_list;
        }
        ret = [];
        for (_i = 0, _len = last_list.length; _i < _len; _i++) {
          last_item = last_list[_i];
          for (_j = 0, _len1 = next_list.length; _j < _len1; _j++) {
            next_item = next_list[_j];
            ret.push(last_item.concat(next_item));
          }
        }
        return makeCombinationOfTwo(ret, remain_lists);
      };
      copy_lists = lists.slice();
      return result = makeCombinationOfTwo(copy_lists.shift().map(function(x) {
        if (x instanceof Array) {
          return x;
        } else {
          return [x];
        }
      }), copy_lists);
    },
    stripEmptyOfList: function(list) {
      var i, item, ret, _i, _len;
      ret = [];
      for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
        item = list[i];
        if (item instanceof Array) {
          ret.push(ulti.stripEmptyOfList(item));
        } else {
          if (item) {
            ret.push(item);
          }
        }
      }
      return ret;
    },
    objDotAccessor: function(obj, path) {
      var attr, path_arr, ret;
      if (!path) {
        return obj;
      }
      path_arr = path.split('.');
      ret = obj;
      while (attr = path_arr.shift()) {
        ret = ret[attr];
      }
      return ret;
    },
    log: function(x, mark, indent) {
      var cache, customStringify, result, surfix;
      surfix = ' - ' + (mark ? mark : '');
      cache = [];
      customStringify = function(k, v) {
        if (typeof v === 'object' && v !== null) {
          if (__indexOf.call(cache, v) >= 0) {
            return 'CR -> ' + v.toString();
          }
          cache.push(v);
        }
        return v;
      };
      result = (JSON.stringify(x, customStringify, indent != null ? indent : 4)) + surfix;
      cache = null;
      console.log(result);
      return result;
    },
    stringEqual: function(source, target, unit) {
      var result, toStr;
      toStr = function(data) {
        var cache, customStringify;
        if (typeof data === 'object') {
          cache = [];
          customStringify = function(k, v) {
            if (typeof v === 'object' && v !== null) {
              if (__indexOf.call(cache, v) >= 0) {
                return 'CR -> ' + v.toString();
              }
              cache.push(v);
            }
            return v;
          };
          data = JSON.stringify(source, customStringify, 0);
          cache = null;
        }
        return data = data.trim().replace(/E![\w0-9]+/g, '!ReprMark!');
      };
      result = toStr(source) === toStr(target);
      return ulti.log(result, unit || '');
    },
    jsonClone: function(json_obj) {
      return JSON.parse(JSON.stringify(json_obj));
    },
    diff: function(orig_list, mod_list) {
      var len, ret;
      orig_list = orig_list.slice();
      mod_list = mod_list.slice();
      len = mod_list.length;
      return ret = [];
    }
  };

  if (typeof self === 'undefined') {
    for (i in ulti) {
      module.exports[i] = ulti[i];
    }
  } else {
    self.ulti = ulti;
  }

}).call(this);

//# sourceMappingURL=ulti.map
