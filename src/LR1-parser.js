// Generated by CoffeeScript 1.7.1
(function() {
  var AST, BNFGrammer, BNFParser, GrammerDict, GrammerNode, IR, SyntaxParser, SyntaxTable, log, ulti,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof self === 'undefined') {
    ulti = require('./ulti.js');
    IR = require('./IR.js');
    BNFParser = require('./BNF-parser.js');
    BNFGrammer = BNFParser.BNFGrammer;
  } else {
    ulti = self.ulti;
    IR = self.IR;
    BNFGrammer = self.BNFGrammer;
  }

  SyntaxTable = function(grammer_content, start_stmt, end_lex) {
    this.start_stmt = start_stmt;
    this.end_lex = end_lex;
    this.raw_bnf_grammer = new BNFGrammer(grammer_content);
    this.raw_bnf_grammer.makePlainBNF();
    this.grammer_dict = new GrammerDict(this.raw_bnf_grammer.bnf_grammer_pairs);
    this.live_grammers = null;
    return this;
  };

  SyntaxTable.prototype.init = function() {
    var closure, _i, _len, _ref;
    this.live_grammers = {};
    _ref = this.start_stmt;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      closure = _ref[_i];
      this.initGrammer2Live(closure, this.end_lex, 0);
    }
    return this.expand(0, null);
  };

  SyntaxTable.prototype.initGrammer2Live = function(closure, end_lex, expand_level) {
    var firsts_closure, reprs, _i, _len, _ref;
    firsts_closure = [];
    _ref = (this.grammer_dict.get(closure))['reprs'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      reprs = _ref[_i];
      if (this.grammer_dict.get(reprs[0])) {
        firsts_closure.push(reprs[0]);
      }
      SyntaxTable.addGrammer2Set(closure, reprs, end_lex, this.live_grammers, expand_level);
    }
    return firsts_closure;
  };

  SyntaxTable.addGrammer2Set = function(closure, repr, end_lex, grammer_set, expand_level) {
    var each_end_lex, first_lex, i, isOneOrMore, _i, _len;
    if (expand_level == null) {
      expand_level = 0;
    }
    repr = repr.slice();
    end_lex = end_lex.slice();
    first_lex = repr.shift();
    isOneOrMore = false;
    if (BNFGrammer.isOneOrMore(first_lex)) {
      first_lex = BNFGrammer.removeSpecialMark(first_lex);
      isOneOrMore = true;
    }
    if (!(first_lex in grammer_set)) {
      grammer_set[first_lex] = [];
    }
    if (isOneOrMore) {
      grammer_set[first_lex].repeat = true;
    }
    for (i = _i = 0, _len = end_lex.length; _i < _len; i = ++_i) {
      each_end_lex = end_lex[i];
      if (BNFGrammer.isOneOrMore(each_end_lex)) {
        end_lex[i] = BNFGrammer.removeSpecialMark(each_end_lex);
      }
    }
    return grammer_set[first_lex].push({
      closure: closure,
      repr: repr,
      end_lex: end_lex,
      expand_level: expand_level
    });
  };

  SyntaxTable.mixGrammers = function(a, b) {
    var i, ret;
    ret = {};
    for (i in a) {
      if (!(i in ret)) {
        ret[i] = [];
      }
      ret[i] = ret[i].concat(a[i]);
    }
    for (i in b) {
      if (!(i in ret)) {
        ret[i] = [];
      }
      ret[i] = ret[i].concat(b[i]);
    }
    log(a, 'mix from a');
    log(b, 'mix from b');
    log(ret, 'mixed');
    return ret;
  };

  SyntaxTable.cloneGrammer = function(a) {
    var closure, item, ret, unit, _i, _len, _ref;
    ret = {};
    for (closure in a) {
      ret[closure] = [];
      if (a[closure].repeat) {
        ret[closure].repeat = true;
      }
      _ref = a[closure];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        item = {
          closure: unit['closure'],
          repr: unit['repr'],
          end_lex: unit['end_lex'],
          expand_level: unit['expand_level']
        };
        ret[closure].push(item);
      }
    }
    return ret;
  };

  SyntaxTable.prototype.moveDot = function(dot_lex, next_lex, expand_level) {
    var dot_grammers, each_grammer, grammer, new_live_grammers, ristrict, _i, _len;
    dot_grammers = this.live_grammers[dot_lex];
    log(dot_lex, 'dot-lex -' + dot_lex);
    if (!dot_grammers) {
      this.live_grammers = {};
      return false;
    }
    new_live_grammers = {};
    ristrict = null;
    if (dot_grammers.repeat) {
      log('repeat!');
      new_live_grammers = SyntaxTable.cloneGrammer(this.live_grammers);
      ristrict = [dot_lex];
    }
    dot_grammers.sort(function(a, b) {
      return b['expand_level'] - a['expand_level'];
    });
    for (_i = 0, _len = dot_grammers.length; _i < _len; _i++) {
      each_grammer = dot_grammers[_i];
      if (!each_grammer['repr'].length) {
        if (__indexOf.call(each_grammer['end_lex'], next_lex) >= 0) {
          return {
            expand_level: each_grammer['expand_level'],
            closure: each_grammer['closure']
          };
        }
      } else {
        ristrict && ristrict.push(BNFGrammer.removeSpecialMark(each_grammer['repr'][0]));
        SyntaxTable.addGrammer2Set(each_grammer['closure'], each_grammer['repr'], each_grammer['end_lex'], new_live_grammers, each_grammer['expand_level']);
      }
    }
    this.live_grammers = new_live_grammers;
    if (dot_grammers.repeat) {
      for (grammer in this.live_grammers) {
        if (__indexOf.call(ristrict, grammer) < 0) {
          delete this.live_grammers[grammer];
        }
      }
    }
    this.expand(expand_level, ristrict);
    return false;
  };

  SyntaxTable.prototype.expand = function(expand_level, ristrict) {
    var closure, closure_id, end_lex, expanded_closures, first_lex, firsts_closure, last_ec_len, x, _i, _len, _ref;
    expanded_closures = [];
    last_ec_len = 0;
    if (ristrict) {
      log(ristrict, 'ristrict');
    }
    while (1) {
      for (closure in this.live_grammers) {
        if (ristrict && __indexOf.call(ristrict, closure) < 0) {
          continue;
        }
        if (this.grammer_dict.get(closure)) {
          end_lex = [];
          _ref = this.live_grammers[closure];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            if (x['repr'].length) {
              first_lex = x['repr'][0];
              first_lex = BNFGrammer.isOneOrMore(first_lex) ? BNFGrammer.removeSpecialMark(first_lex) : first_lex;
              ulti.uniqueConcat(end_lex, this.grammer_dict.findFirst(first_lex));
            } else {
              ulti.uniqueConcat(end_lex, this.end_lex);
              ulti.uniqueConcat(end_lex, x['end_lex']);
            }
            if (this.live_grammers[closure].repeat) {
              ulti.uniqueConcat(end_lex, this.grammer_dict.findFirst(closure));
            }
            closure_id = closure + end_lex.join('');
            if (__indexOf.call(expanded_closures, closure_id) >= 0) {
              end_lex = [];
            }
          }
          if (!end_lex.length) {
            continue;
          }
          expanded_closures.push(closure_id);
          firsts_closure = this.initGrammer2Live(closure, end_lex, expand_level);
          if (ristrict) {
            log(firsts_closure, 'firsts_closure');
            ulti.uniqueConcat(ristrict, firsts_closure);
          }
        }
      }
      if (last_ec_len === expanded_closures.length) {
        break;
      }
      last_ec_len = expanded_closures.length;
    }
    return null;
  };

  GrammerDict = function(bnf_grammer_pairs) {
    var closure, line, repr, reprs, _i, _j, _len, _len1;
    this.bnf_grammer_pairs = bnf_grammer_pairs;
    this.dict_map = {};
    for (_i = 0, _len = bnf_grammer_pairs.length; _i < _len; _i++) {
      line = bnf_grammer_pairs[_i];
      closure = line[0];
      reprs = line[1] instanceof Array ? line[1] : [line[1]];
      if (!(closure in this.dict_map)) {
        this.dict_map[closure] = GrammerDict.initClosure();
      }
      for (_j = 0, _len1 = reprs.length; _j < _len1; _j++) {
        repr = reprs[_j];
        this.dict_map[closure]['reprs'].push(repr.split(/\s+/));
      }
    }
    this.makeFirstSets();
    return this;
  };

  GrammerDict.initClosure = function() {
    return {
      reprs: [],
      first: [],
      follows: []
    };
  };

  GrammerDict.prototype.get = function(closure) {
    if (BNFGrammer.isOneOrMore(closure)) {
      closure = BNFGrammer.removeSpecialMark(closure);
    }
    return this.dict_map[closure];
  };

  GrammerDict.prototype.makeFirstSets = function() {
    var closure, closure_key, first_set, getFirst, _results;
    getFirst = function(closure_key, first_set, pushed_closures) {
      var closure, repr, _i, _len, _ref, _ref1, _results;
      closure = this.dict_map[closure_key];
      pushed_closures.push(closure_key);
      _ref = closure['reprs'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        repr = _ref[_i];
        if (_ref1 = repr[0], __indexOf.call(pushed_closures, _ref1) >= 0) {
          continue;
        }
        if (repr[0] in this.dict_map) {
          _results.push(getFirst.call(this, repr[0], first_set, pushed_closures));
        } else {
          _results.push(ulti.uniquePush(first_set, repr[0]));
        }
      }
      return _results;
    };
    _results = [];
    for (closure_key in this.dict_map) {
      closure = this.dict_map[closure_key];
      first_set = closure['first'];
      _results.push(getFirst.call(this, closure_key, first_set, []));
    }
    return _results;
  };

  GrammerDict.prototype.findFirst = function(closures) {
    var closure, ret, _i, _len;
    if (!(closures instanceof Array)) {
      closures = [closures];
    }
    ret = [];
    for (_i = 0, _len = closures.length; _i < _len; _i++) {
      closure = closures[_i];
      if (!(closure in this.dict_map)) {
        ulti.uniquePush(ret, closure);
      } else {
        ulti.uniqueConcat(ret, this.dict_map[closure]['first']);
      }
    }
    return ret;
  };

  GrammerNode = function(lex, parent, leaves) {
    if (parent == null) {
      parent = null;
    }
    if (leaves == null) {
      leaves = [];
    }
    this.parent = null;
    this.leaves = leaves;
    this.lex = lex;
    this.value = null;
    if (parent) {
      this.linkParent(parent);
    }
    return this;
  };

  GrammerNode.prototype.isName = function(lex) {
    return lex === this.lex;
  };

  GrammerNode.prototype.getValue = function() {
    return this.value;
  };

  GrammerNode.prototype.setValue = function(val) {
    return this.value = val;
  };

  GrammerNode.prototype.appendLeaf = function(leaf) {
    if (!this.hasLeaf(leaf)) {
      return this.leaves.push(leaf);
    }
  };

  GrammerNode.prototype.prependLeaf = function(leaf) {
    if (!this.hasLeaf(leaf)) {
      return this.leaves.unshift(leaf);
    }
  };

  GrammerNode.prototype.hasLeaf = function(leaf) {
    return __indexOf.call(this.leaves, leaf) >= 0;
  };

  GrammerNode.prototype.findLeaf = function(lex_name) {
    var leaf, _i, _len, _ref;
    _ref = this.leaves;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      leaf = _ref[_i];
      if (leaf.lex === lex_name) {
        return leaf;
      }
    }
    return null;
  };

  GrammerNode.prototype.linkParent = function(parent, use_prepend) {
    if (use_prepend == null) {
      use_prepend = null;
    }
    this.parent = parent;
    if (use_prepend) {
      return parent.prependLeaf(this);
    } else {
      return parent.appendLeaf(this);
    }
  };

  AST = function(syntax_tree, patterns) {
    if (patterns == null) {
      patterns = [];
    }
    this.syntax_tree = syntax_tree;
    this.patterns = patterns;
    AST.cutLeaves(this.syntax_tree, this.patterns);
    return this;
  };

  AST.cutLeaves = function(syntax_tree, patterns) {
    var walk;
    walk = function(node) {
      var leaf, neighbor, new_parent_leaves, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      _ref = node.leaves;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        leaf = _ref[_i];
        walk(leaf);
      }
      if ((_ref1 = node.lex, __indexOf.call(patterns, _ref1) >= 0) || (node.lex.slice(0, 2) === 'E!' && node.value === null)) {
        new_parent_leaves = [];
        _ref2 = node.parent.leaves;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          neighbor = _ref2[_j];
          if (neighbor === node) {
            new_parent_leaves = new_parent_leaves.concat(node.leaves);
            _ref3 = node.leaves;
            for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
              leaf = _ref3[_k];
              leaf.parent = node.parent;
            }
          } else {
            new_parent_leaves = new_parent_leaves.concat(neighbor);
          }
        }
        node.parent.leaves = new_parent_leaves;
      }
      if (!node.leaves.length) {
        delete node.leaves;
      }
      if (node.value === null) {
        return delete node.value;
      }
    };
    return walk(syntax_tree);
  };

  SyntaxParser = function(input_lex) {
    this.raw_input_lex = input_lex;
    this.input_lex = input_lex.map(function(x) {
      if (x instanceof Array) {
        return x[0];
      } else {
        return x;
      }
    });
    this.input_val = input_lex.map(function(x) {
      if (x instanceof Array) {
        return x[1];
      } else {
        return null;
      }
    });
    this.stack = [];
    this.sync_lex = [];
    this.reduce_cache = {};
    this.reduce_cache_len = {};
    this.tree = new GrammerNode('Syntax');
    return this;
  };

  SyntaxParser.flow = function(args) {
    var ast, ast_cutter, end_lex, grammer, lex_list, mix_map, start_stmt, sync_lex, syntax_parser, syntax_table;
    console.log('SyntaxParser');
    grammer = args.grammer;
    start_stmt = args.start_stmt;
    end_lex = args.end_lex;
    sync_lex = args.sync_lex || [];
    lex_list = args.lex_list;
    mix_map = args.mix_map;
    ast_cutter = args.ast_cutter;
    SyntaxParser.Mix.mixer = function() {
      return mix_map.arrange.apply(mix_map, arguments);
    };
    syntax_table = new SyntaxTable(grammer, start_stmt, end_lex);
    syntax_parser = new SyntaxParser(lex_list);
    syntax_parser.sync_lex = sync_lex;
    syntax_parser.parseTable(syntax_table);
    ast = syntax_parser.getAST(ast_cutter);
    args.ast = ast.syntax_tree;
    return SyntaxParser.Mix.mixer = null;
  };

  SyntaxParser.prototype.getAST = function(patterns) {
    return new AST(this.tree, patterns);
  };

  SyntaxParser.prototype.shift = function() {
    if (this.input_lex.length) {
      return this.stack.push(this.input_lex.shift());
    } else {
      return false;
    }
  };

  SyntaxParser.checkIfReduce = function(syntax_table, stack, lookahead) {
    var cached_index, index, len, result, ret, spcr, _i, _ref, _ref1;
    spcr = SyntaxParser.checkIfReduce;
    cached_index = spcr.getCachedIndex(stack);
    if (cached_index > -1) {
      syntax_table.live_grammers = spcr.checkedLiveGrammers[cached_index];
    }
    if (!syntax_table.live_grammers) {
      syntax_table.init();
    }
    len = stack.length;
    stack.push(lookahead);
    ret = [];
    for (index = _i = _ref = cached_index + 1, _ref1 = len - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = _ref <= _ref1 ? ++_i : --_i) {
      log(syntax_table.live_grammers, 'before live grammer');
      result = syntax_table.moveDot(stack[index], stack[index + 1], index + 1);
      log(result, 'after move dot');
      log(syntax_table.live_grammers, 'live grammer');
      log(index + 1, 'move dot index');
      if (result) {
        ret = stack.slice(0, result['expand_level']);
        ret.push(result['closure']);
      }
    }
    stack.pop();
    if (ret.length) {
      spcr.lastCheckedStack = ret.slice(0, -1);
    } else {
      spcr.lastCheckedStack = stack.slice();
    }
    spcr.checkedLiveGrammers = spcr.checkedLiveGrammers.slice(0, spcr.lastCheckedStack.length);
    while (spcr.checkedLiveGrammers.length < spcr.lastCheckedStack.length) {
      spcr.checkedLiveGrammers.push('');
    }
    if (!ret.length) {
      spcr.checkedLiveGrammers[spcr.checkedLiveGrammers.length - 1] = syntax_table.live_grammers;
    }
    if (ret.length) {
      return ret;
    } else {
      return stack;
    }
  };

  SyntaxParser.checkIfReduce.lastCheckedStack = [];

  SyntaxParser.checkIfReduce.checkedLiveGrammers = [];

  SyntaxParser.checkIfReduce.getCachedIndex = function(stack) {
    var index, item, scif, _i, _len;
    scif = SyntaxParser.checkIfReduce;
    for (index = _i = 0, _len = stack.length; _i < _len; index = ++_i) {
      item = stack[index];
      if (scif.lastCheckedStack[index] !== item) {
        index--;
        break;
      }
    }
    if (index === stack.length) {
      return index - 1;
    } else {
      return index;
    }
  };

  SyntaxParser.prototype.multiReverseReduce = function(syntax_table) {
    var i, result, _i, _ref, _results;
    _results = [];
    for (i = _i = 1, _ref = this.stack.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
      syntax_table.init();
      result = SyntaxParser.checkIfReduce(syntax_table, this.stack.slice(-i), this.input_lex[0]);
      if (result) {
        this.stack = this.stack.slice(0, this.stack.length - i);
        this.stack.push(result);
        if (i > 1) {
          this.reduce(syntax_table);
          break;
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  SyntaxParser.prototype.MultiReduce = function(syntax_table) {
    var i, result, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.stack.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      syntax_table.init();
      result = SyntaxParser.checkIfReduce(syntax_table, this.stack.slice(i, this.stack.length), this.input_lex[0]);
      if (result) {
        this.stack = this.stack.slice(0, i);
        this.stack.push(result);
        this.reduce(syntax_table);
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  SyntaxParser.prototype.reduce = function(syntax_table, value_assign) {
    var last_stmt_index, result, stack_changed, sync_index, sync_len;
    if (value_assign == null) {
      value_assign = true;
    }
    log(this.stack, 'before reduce');
    this.generateTree(value_assign);
    syntax_table.live_grammers = null;
    result = SyntaxParser.checkIfReduce(syntax_table, this.stack, this.input_lex[0]);
    sync_index = this.sync_lex.indexOf(result[result.length - 1]);
    sync_len = this.sync_lex.length;
    if (sync_index > -1 && sync_index !== sync_len - 1 && this.stack === result) {
      last_stmt_index = result.lastIndexOf(this.sync_lex[this.sync_lex.length - 1]);
      result = result.slice(0, last_stmt_index + 1).concat(this.sync_lex[sync_index + 1]);
    }
    if (result) {
      stack_changed = this.stack !== result;
      value_assign = result.length > this.stack.length ? true : false;
      if (stack_changed) {
        this.stack = result;
        return this.reduce(syntax_table, value_assign);
      }
    }
  };

  SyntaxParser.prototype.generateTree = function(value_assign) {
    var curr_len, curr_node_leaves_len, curr_stack, i, new_gt, _i, _ref;
    curr_stack = this.stack.slice();
    curr_len = curr_stack.length;
    curr_node_leaves_len = this.tree.leaves.length;
    if (curr_len > curr_node_leaves_len) {
      new_gt = new GrammerNode(curr_stack[curr_len - 1], this.tree);
    } else {
      for (i = _i = 0, _ref = curr_len - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (!this.tree.leaves[i].isName(curr_stack[i])) {
          break;
        }
      }
      new_gt = new GrammerNode(curr_stack[curr_len - 1]);
      while (i++ !== curr_node_leaves_len) {
        this.tree.leaves.pop().linkParent(new_gt, true);
      }
      new_gt.linkParent(this.tree);
    }
    if (value_assign) {
      SyntaxParser.Mix(['SyntaxNode', new_gt], ['Lex', this.raw_input_lex[this.raw_input_lex.length - this.input_val.length]]);
      return new_gt.value = this.input_val.shift();
    }
  };

  SyntaxParser.prototype.parseTable = function(syntax_table) {
    var i, len, _i, _results;
    len = this.input_lex.length - 1;
    _results = [];
    for (i = _i = 1; 1 <= len ? _i <= len : _i >= len; i = 1 <= len ? ++_i : --_i) {
      this.shift(syntax_table);
      log(this.stack, 'before reduce');
      this.reduce(syntax_table);
      _results.push(log(this.stack, 'after reduce'));
    }
    return _results;
  };

  SyntaxParser.Mix = function() {
    if (!SyntaxParser.Mix.mixer) {
      return null;
    }
    return SyntaxParser.Mix.mixer.apply(this, arguments);
  };

  if (typeof self === 'undefined') {
    module.exports.SyntaxTable = SyntaxTable;
    module.exports.SyntaxParser = SyntaxParser;
    module.exports.AST = AST;
  } else {
    self.SyntaxTable = SyntaxTable;
    self.SyntaxParser = SyntaxParser;
    self.AST = AST;
  }

  log = function() {};

  return;

  log = ulti.log;

}).call(this);

//# sourceMappingURL=LR1-parser.map
