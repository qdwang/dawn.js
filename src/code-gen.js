// Generated by CoffeeScript 1.7.1
(function() {
  var CodeGen, GenCodeFromLeaves, GenWalker, GrammerParser, Zipper, ulti;

  if (typeof self === 'undefined') {
    ulti = require('./ulti.js');
    Zipper = require('./Zipper.js');
    Zipper = Zipper.Zipper;
  } else {
    ulti = self.ulti;
    Zipper = self.Zipper;
  }

  CodeGen = function(grammer, ast) {
    var grammer_map;
    grammer_map = GrammerParser(grammer);
    return GenWalker(grammer_map, ast.leaves);
  };

  GenWalker = function(grammer, ast_leaves) {
    var node, ret, _i, _len;
    ret = '';
    if (!ast_leaves) {
      return ret;
    }
    for (_i = 0, _len = ast_leaves.length; _i < _len; _i++) {
      node = ast_leaves[_i];
      if (node['lex'] in grammer) {
        ret += GenCodeFromLeaves(grammer[node['lex']], node['leaves'], grammer);
      }
      if (node['leaves']) {
        ret += GenWalker(grammer, node['leaves']);
      }
    }
    return ret;
  };

  GenCodeFromLeaves = function(gen_order, ast_leaves, grammer) {
    var gen_item, ret, stratchValues, _i, _len;
    ret = '';
    if (!ast_leaves) {
      return ret;
    }
    stratchValues = function(gen_item, leaves) {
      var expand_grammer, inner_gen_item, leave, selected, _i, _j, _len, _len1, _selected_index;
      expand_grammer = grammer[':' + gen_item];
      for (_i = 0, _len = leaves.length; _i < _len; _i++) {
        leave = leaves[_i];
        if (leave.lex === gen_item) {
          if (leave.value !== void 0) {
            return leave.value;
          }
          if (expand_grammer) {
            ret = '';
            _selected_index = {};
            for (_j = 0, _len1 = expand_grammer.length; _j < _len1; _j++) {
              inner_gen_item = expand_grammer[_j];
              if (inner_gen_item.charAt(0) === '"') {
                ret += inner_gen_item;
              } else {
                if (!(inner_gen_item in _selected_index)) {
                  _selected_index[inner_gen_item] = 0;
                } else {
                  _selected_index[inner_gen_item] += 1;
                }
                selected = Zipper.select(leave, inner_gen_item);
                ret += selected[_selected_index[inner_gen_item]].value;
              }
            }
            return ret;
          }
        }
      }
      return gen_item;
    };
    for (_i = 0, _len = gen_order.length; _i < _len; _i++) {
      gen_item = gen_order[_i];
      if (gen_item.charAt(0) === '"') {
        ret += gen_item;
      } else {
        ret += stratchValues(gen_item, ast_leaves);
      }
    }
    return ret;
  };

  GrammerParser = function(grammer) {
    var gen_order, grammer_map, in_string, l, line, lines_pair, raw_lines, raw_order, _i, _len;
    raw_lines = grammer.split('\n');
    lines_pair = raw_lines.filter(function(x) {
      return x;
    }).map(function(x) {
      return x.replace('\\n', '\n').split('->');
    });
    grammer_map = {};
    for (_i = 0, _len = lines_pair.length; _i < _len; _i++) {
      line = lines_pair[_i];
      grammer_map[line[0].trim()] = null;
      gen_order = [''];
      raw_order = line[1].trim();
      l = raw_order.length;
      in_string = false;
      while (l--) {
        if (raw_order[l] === '"') {
          if (!in_string) {
            in_string = true;
            gen_order[0] = '"';
          } else {
            in_string = false;
            gen_order[0] = '"' + gen_order[0];
          }
        } else {
          if (in_string) {
            gen_order[0] = raw_order[l] + gen_order[0];
          } else if (raw_order[l] === ' ') {
            if (gen_order[0].length !== 0) {
              gen_order.unshift('');
            }
          } else {
            gen_order[0] = raw_order[l] + gen_order[0];
          }
        }
      }
      grammer_map[line[0].trim()] = gen_order;
    }
    return grammer_map;
  };

  if (typeof self === 'undefined') {
    module.exports.CodeGen = CodeGen;
  } else {
    self.CodeGen = CodeGen;
  }

}).call(this);

//# sourceMappingURL=code-gen.map
