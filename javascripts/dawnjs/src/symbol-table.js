// Generated by CoffeeScript 1.8.0
(function() {
  var IR, SymbolTable, log, util,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof self === 'undefined') {
    util = require('./util.js');
    IR = require('./IR.js');
  } else {
    util = self.util;
    IR = self.IR;
  }

  SymbolTable = function(markers) {
    this.markers = markers;
    this.stack = [];
    this.parent = null;
    return this;
  };

  SymbolTable.flow = function(args) {
    var ast, markers, mix_map, scope_rules, symbol_tables;
    console.log('SymbolTable');
    ast = args.ast;
    markers = args.markers;
    scope_rules = args.scope_rules;
    mix_map = args.mix_map;
    SymbolTable.Mix.mixer = function() {
      return mix_map.arrange.apply(mix_map, arguments);
    };
    symbol_tables = SymbolTable.walkGenerate(ast, markers, scope_rules);
    args.symbol_tables = symbol_tables;
    return SymbolTable.Mix.mixer = null;
  };

  SymbolTable.prototype.convert = function(obj) {
    var i, obj_empty;
    obj_empty = true;
    for (i in obj) {
      obj_empty = false;
      if (i in this.markers && this.markers[i] !== null && typeof obj[i] === 'object') {
        obj[i] = this.markers[i](obj[i]);
      }
    }
    return obj_empty;
  };

  SymbolTable.match = function(record, cond_obj) {
    var cond;
    for (cond in cond_obj) {
      if (record[cond] !== cond_obj[cond]) {
        return false;
      }
    }
    return true;
  };

  SymbolTable.prototype.push = function(obj) {
    var is_obj_empty;
    is_obj_empty = this.convert(obj);
    if (!is_obj_empty) {
      return this.stack.push(obj);
    }
  };

  SymbolTable.prototype.concat = function() {
    var arg_arr, obj, _i, _len, _results;
    arg_arr = [].slice.call(arguments);
    _results = [];
    for (_i = 0, _len = arg_arr.length; _i < _len; _i++) {
      obj = arg_arr[_i];
      _results.push(this.push(obj));
    }
    return _results;
  };

  SymbolTable.prototype.lookUpTop = function(cond_obj) {
    var found, is_obj_empty, l, record, _i, _ref;
    is_obj_empty = this.convert(cond_obj);
    if (is_obj_empty) {
      return null;
    }
    found = false;
    for (l = _i = _ref = this.stack.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; l = _ref <= 0 ? ++_i : --_i) {
      record = this.stack[l];
      if (SymbolTable.match(record, cond_obj)) {
        found = record;
        break;
      }
    }
    if (found) {
      return found;
    }
    if (!found && this.parent) {
      return this.parent.lookUpTop(cond_obj);
    } else {
      return null;
    }
  };

  SymbolTable.prototype.filter = function(filter_method, scope_mode) {
    var record, ret, _i, _len, _ref;
    if (scope_mode == null) {
      scope_mode = 0;
    }

    /*
        scope_mode:
            0 -> only lookup current scope,
            1 -> will lookup parent scope if no matches in current scope,
            2 -> matches in all scopes
     */
    ret = [];
    _ref = this.stack;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      record = _ref[_i];
      if (filter_method(record)) {
        ret.push(record);
      }
    }
    if (scope_mode === 1 && !ret.length && this.parent) {
      ret = ret.concat(this.parent.filter(filter_method, 1));
    } else if (scope_mode === 2 && this.parent) {
      ret = ret.concat(this.parent.filter(filter_method, 2));
    }
    return ret;
  };

  SymbolTable.walkGenerate = function(ast, markers, scope_rules) {
    var ret, store_record, walk;
    ret = [];
    store_record = function(obj, stored) {
      var key, new_records_len, _results;
      new_records_len = stored.length;
      _results = [];
      for (key in obj) {
        if (key in stored[new_records_len - 1]) {
          _results.push(stored.push(obj));
        } else {
          _results.push(stored[new_records_len - 1][key] = obj[key]);
        }
      }
      return _results;
    };
    walk = function(node, curr_scope_table, stored, reduce_result) {
      var leaf, new_scope_table, obj, parse_leaves, record_obj, _i, _len, _ref, _ref1, _results;
      parse_leaves = true;
      if (_ref = node.lex, __indexOf.call(scope_rules, _ref) >= 0) {
        new_scope_table = new SymbolTable(markers);
        new_scope_table.parent = curr_scope_table;
        curr_scope_table = new_scope_table;
        stored = [{}];
        reduce_result = true;
      }
      if (node.lex in markers) {
        record_obj = {};
        record_obj[node.lex] = node;
        store_record(record_obj, stored);
        parse_leaves = false;
      }
      if (node.leaves) {
        _ref1 = node.leaves;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          leaf = _ref1[_i];
          walk(leaf, curr_scope_table, stored, false);
        }
      }
      if (reduce_result) {
        ret.push(curr_scope_table);
        SymbolTable.Mix(['SyntaxNode', node], ['SymbolTable', curr_scope_table]);
        _results = [];
        while (obj = stored.shift()) {
          _results.push(curr_scope_table.push(obj));
        }
        return _results;
      }
    };
    walk(ast, new SymbolTable(markers), [{}], true);
    return ret;
  };

  SymbolTable.Mix = function() {
    if (!SymbolTable.Mix.mixer) {
      return null;
    }
    return SymbolTable.Mix.mixer.apply(this, arguments);
  };

  if (typeof self === 'undefined') {
    module.exports.SymbolTable = SymbolTable;
  } else {
    self.SymbolTable = SymbolTable;
  }

  log = function() {};

  log = util.log;

}).call(this);

//# sourceMappingURL=symbol-table.js.map
